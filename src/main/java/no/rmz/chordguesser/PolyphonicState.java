package no.rmz.chordguesser;



    // Drop the stupid timestamp!
/**
 * The state of the sound being generated by the instrument. Each entry contains
 * a collection of single note states, each of which describing the latest
 * active event for that note. A "key up" event will mean that no sound is being
 * generated on that note any longer, so the corresponding state is then
 * removed.
 */
public final class PolyphonicState {

    private final static int MAX_NO_OF_MIDI_NOTES = 128;

    private final MonophonicState[] monoStates =
            new MonophonicState[MAX_NO_OF_MIDI_NOTES];

    public PolyphonicState() {
        for (int i = 0 ; i < MAX_NO_OF_MIDI_NOTES ; i++) {
            monoStates[i] = new MonophonicState(i);
        }
    }

    public static PolyphonicStateBuilder newBuilder() {
        return new PolyphonicStateBuilder();
    }


    public static class PolyphonicStateBuilder {
        
        private int [] octaveRepeatedPattern;
        public PolyphonicStateBuilder setOctaveRepeatedPatterPattern(final int[] pattern) {
            octaveRepeatedPattern = pattern;
            return this;
        } 
        
        public  PolyphonicState build() {
            final PolyphonicState result = new PolyphonicState();
            // XXX Do some initialization, based on the octaveRepeatdPattern.
            return result;
        }
    }


    public void on(int i) {
        checkArg(i);
        monoStates[i].on();
    }

    public void off(int i) {
        checkArg(i);
        monoStates[i].off();
    }

    private void checkArg(int i) {
        if (i < 0 || i >= MAX_NO_OF_MIDI_NOTES) {
            throw new IllegalArgumentException("Illegal MIDI note: " + i);
        }
    }
}
